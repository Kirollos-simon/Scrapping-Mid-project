{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "44a8b8a4",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd \n",
    "import numpy as np \n",
    "import plotly.express as px \n",
    "import plotly.figure_factory as ff \n",
    "import plotly.graph_objects as go \n",
    "import streamlit as st"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "30a17eae",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'1.39.0'"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import streamlit\n",
    "streamlit.__version__"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "b0d0b0d8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Overwriting scrapping.py\n"
     ]
    }
   ],
   "source": [
    "%%writefile scrapping.py\n",
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import plotly.express as px\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "# Function to load data from CSV file\n",
    "def load_data():\n",
    " file_path = r\"C:\\Users\\simonk03\\OneDrive - Heineken International\\Data siense\\Master Data sciense\\PowerBI Projects\\Mid project\\Finaalsss\\Mid project Scrapping\\cleaned_scrapping_provision_from_modified1.csv\"\n",
    " return pd.read_csv(file_path)\n",
    "\n",
    "data = load_data()\n",
    "\n",
    "# Dashboard title\n",
    "st.title(\"Scrapping Provision Dashboard\")\n",
    "\n",
    "# Sidebar navigation for pages\n",
    "st.sidebar.title(\"Navigation\")\n",
    "page = st.sidebar.radio(\"Go to\", [\"Summary Dashboard\", \"Detailed Analysis\", \"Risk & Financial Insights\", \"Additional Insights\"])\n",
    "\n",
    "# Page 1: Summary Dashboard\n",
    "if page == \"Summary Dashboard\":\n",
    " st.header(\"Page 1: Summary Statistics\")\n",
    " \n",
    " # KPIs: Total Quantity, Total Value, Unique Products\n",
    " with st.container():\n",
    "  col1, col2, col3 = st.columns(3)\n",
    "  with col1:\n",
    "   st.metric(\"Total Quantity\", f\"{data['Quantity'].sum():,.2f}\")\n",
    "  with col2:\n",
    "   st.metric(\"Total Value (EGP)\", f\"{data['Value in EGP'].sum():,.2f}\")\n",
    "  with col3:\n",
    "   st.metric(\"Unique Products\", len(data[\"Product\"].unique()))\n",
    "\n",
    " # Total Value by Segement\n",
    " if \"Segement\" in data.columns:\n",
    "  st.subheader(\"Total Value by Segement\")\n",
    "  segement_value = data.groupby(\"Segement\")[\"Value in EGP\"].sum().reset_index()\n",
    "  fig_segement = px.bar(segement_value, \n",
    "   x=\"Segement\", \n",
    "   y=\"Value in EGP\", \n",
    "   color=\"Segement\", \n",
    "   title=\"Total Value by Segement\", \n",
    "   labels={\"Segement\": \"Segement\", \"Value in EGP\": \"Total Value (EGP)\"},\n",
    "   color_continuous_scale=\"Viridis\", \n",
    "   text=\"Value in EGP\")\n",
    "  fig_segement.update_traces(texttemplate='%{text:.2s}', textposition='outside', marker=dict(line=dict(width=1, color='DarkSlateGrey')))\n",
    "  fig_segement.update_layout(barmode='group', xaxis_tickangle=-45, xaxis_title='Segement', yaxis_title='Total Value (EGP)', template=\"plotly_white\")\n",
    "  st.plotly_chart(fig_segement)\n",
    "\n",
    " # Total Value by Plant and Segement (Grouped/Stacked Bar Chart)\n",
    " if \"Plant\" in data.columns and \"Segement\" in data.columns:\n",
    "  st.subheader(\"Total Value by Plant and Segement\")\n",
    "  plant_segment_value = data.groupby([\"Plant\", \"Segement\"])[\"Value in EGP\"].sum().reset_index()\n",
    "  fig_plant_segment = px.bar(plant_segment_value, \n",
    "   x=\"Plant\", \n",
    "   y=\"Value in EGP\", \n",
    "   color=\"Segement\", \n",
    "   title=\"Total Value by Plant and Segement\", \n",
    "   labels={\"Plant\": \"Plant\", \"Value in EGP\": \"Total Value (EGP)\", \"Segement\": \"Segement\"},\n",
    "   barmode=\"stack\", \n",
    "   color_discrete_sequence=px.colors.qualitative.Set2)\n",
    "  fig_plant_segment.update_layout(xaxis_title='Plant', \n",
    "   yaxis_title='Total Value (EGP)', \n",
    "   template=\"plotly_white\", \n",
    "   xaxis_tickangle=-45)\n",
    "  st.plotly_chart(fig_plant_segment)\n",
    "\n",
    "# Page 2: Detailed Analysis\n",
    "elif page == \"Detailed Analysis\":\n",
    " st.header(\"Page 2: Detailed Analysis\")\n",
    " \n",
    " # Filter options for month and plant\n",
    " month_filter = st.selectbox(\"Select Month\", options=[\"All\"] + list(data[\"Scrapping Month\"].unique()))\n",
    " plant_filter = st.selectbox(\"Select Plant\", options=[\"All\"] + list(data[\"Plant\"].unique()))\n",
    "\n",
    " # Filter the data based on selected month and plant\n",
    " filtered_data = data\n",
    " if month_filter != \"All\":\n",
    "  filtered_data = filtered_data[filtered_data[\"Scrapping Month\"] == month_filter]\n",
    " if plant_filter != \"All\":\n",
    "  filtered_data = filtered_data[filtered_data[\"Plant\"] == plant_filter]\n",
    "\n",
    " # Total Value per Classification (Bar Chart)\n",
    " st.subheader(\"Total Value per Classification (Plotly)\")\n",
    " classification_value = filtered_data.groupby(\"Classification\")[\"Value in EGP\"].sum().reset_index()\n",
    " fig_classification = px.bar(classification_value, \n",
    "  x=\"Classification\", \n",
    "  y=\"Value in EGP\", \n",
    "  color=\"Classification\", \n",
    "  title=\"Total Value per Classification\",\n",
    "  labels={\"Value in EGP\": \"Total Value (EGP)\"},\n",
    "  color_continuous_scale=\"Viridis\")\n",
    " fig_classification.update_layout(xaxis_tickangle=-45, template=\"plotly_white\", yaxis_title=\"Total Value (EGP)\")\n",
    " st.plotly_chart(fig_classification)\n",
    " \n",
    " # Product Details by Classification (Table with Red High Value)\n",
    " st.subheader(\"Product Details by Classification\")\n",
    " product_table = filtered_data.groupby([\"Product\", \"Classification\"])[\"Value in EGP\"].sum().reset_index()\n",
    " product_table = product_table.sort_values(by=\"Value in EGP\", ascending=False)\n",
    " grand_total_value = product_table[\"Value in EGP\"].sum()\n",
    " product_table[\"% of Grand Total\"] = (product_table[\"Value in EGP\"] / grand_total_value) * 100\n",
    " product_table[\"% of Grand Total\"] = product_table[\"% of Grand Total\"].apply(lambda x: f\"{x:.2f}%\")\n",
    " def color_high_value(val):\n",
    "  if val > product_table[\"Value in EGP\"].quantile(0.9):\n",
    "   return \"color: red\"\n",
    "  return \"\"\n",
    " styled_table = product_table.style.applymap(color_high_value, subset=[\"Value in EGP\"])\n",
    " st.dataframe(styled_table)\n",
    "\n",
    "# Page 3: Risk & Financial Insights\n",
    "elif page == \"Risk & Financial Insights\":\n",
    " st.header(\"Page 3: Risk and Financial Insights\")\n",
    " \n",
    " # Filter options for plant\n",
    " plant_filter = st.selectbox(\"Select Plant\", options=[\"All\"] + list(data[\"Plant\"].unique()))\n",
    "\n",
    " # Filter the data based on selected plant\n",
    " filtered_data = data if plant_filter == \"All\" else data[data[\"Plant\"] == plant_filter]\n",
    " \n",
    " # Pie chart: Risk Level Distribution (Plotly)\n",
    " st.subheader(\"Risk Level Distribution (Plotly)\")\n",
    " fig = px.pie(filtered_data, names=\"Risk Level\", title=\"Risk Level Distribution\")\n",
    " st.plotly_chart(fig)\n",
    " \n",
    " # Scatter Plot: Value vs. Quantity by Risk Level (Plotly)\n",
    " st.subheader(\"Value vs. Quantity by Risk Level (Plotly)\")\n",
    " fig = px.scatter(filtered_data, x=\"Quantity\", y=\"Value in EGP\", color=\"Risk Level\", \n",
    "  title=\"Value vs. Quantity by Risk Level\")\n",
    " st.plotly_chart(fig)\n",
    " \n",
    " # Boxplot: Value by Risk Level (Matplotlib)\n",
    " st.subheader(\"Value by Risk Level (Matplotlib)\")\n",
    " plt.figure(figsize=(10, 6))\n",
    " filtered_data.boxplot(column=\"Value in EGP\", by=\"Risk Level\", grid=False, patch_artist=True, \n",
    "  boxprops=dict(facecolor=\"lightblue\"))\n",
    " plt.xlabel(\"Risk Level\")\n",
    " plt.ylabel(\"Value in EGP\")\n",
    " plt.title(\"Value Distribution by Risk Level\")\n",
    " plt.suptitle(\"\")  # Remove default title from boxplot\n",
    " st.pyplot(plt)\n",
    "\n",
    "# Page 4: Additional Insights\n",
    "elif page == \"Additional Insights\":\n",
    " st.header(\"Page 4: Three-Level Hierarchical Scrapping Insights\")\n",
    " \n",
    " # Total Value by Level 1\n",
    " st.subheader(\"Total Value by Level 1\")\n",
    " level1_value = data.groupby(\"Level 1\")[\"Value in EGP\"].sum().reset_index()\n",
    " fig_level1 = px.bar(level1_value, \n",
    "  x=\"Level 1\", \n",
    "  y=\"Value in EGP\", \n",
    "  color=\"Level 1\", \n",
    "  title=\"Total Value by Level 1\",\n",
    "  labels={\"Value in EGP\": \"Total Value (EGP)\"},\n",
    "  color_discrete_sequence=px.colors.qualitative.Set3)\n",
    " fig_level1.update_layout(xaxis_tickangle=-45, template=\"plotly_white\", yaxis_title=\"Total Value (EGP)\")\n",
    " st.plotly_chart(fig_level1)\n",
    " \n",
    " # Sunburst Chart: Value Distribution across Levels\n",
    " st.subheader(\"Value Distribution across Levels (Sunburst Chart)\")\n",
    " sunburst_data = data.groupby([\"Level 1\", \"Level 2\", \"Level 3\"])[\"Value in EGP\"].sum().reset_index()\n",
    " fig_sunburst = px.sunburst(sunburst_data, \n",
    "  path=[\"Level 1\", \"Level 2\", \"Level 3\"], \n",
    "  values=\"Value in EGP\", \n",
    "  title=\"Value Distribution across Levels\",\n",
    "  color=\"Level 1\",\n",
    "  color_discrete_sequence=px.colors.qualitative.Pastel)\n",
    " fig_sunburst.update_layout(template=\"plotly_white\")\n",
    " st.plotly_chart(fig_sunburst)\n",
    " \n",
    " # Detailed Classification Insights\n",
    " st.subheader(\"Detailed Classification Insights\")\n",
    " detailed_classification = data.groupby([\"Classification\", \"Level 1\", \"Level 2\", \"Level 3\"])[[\"Quantity\", \"Value in EGP\"]].sum().reset_index()\n",
    " st.dataframe(detailed_classification)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b75c96ce",
   "metadata": {},
   "outputs": [],
   "source": [
    "    ! streamlit run Scrapping.py"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
